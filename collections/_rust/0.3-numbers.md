---
title: "Rust - Data Types: Numbers"
excerpt: "Guide to understand rust"
header:
  image: "/assets/images/academy/rust.svg"
last_modified_at: 2023-06-28 00:00:00 +00:00
toc: true
---

> :information_source: **Note:** Read the [offical docs](https://www.rust-lang.org/learn) to get the most updated information.

## Data Types


Rust doesn't do any implicit type **conversion**. In cases when many types are possible we must add a type **annotation**, like this: `: u32`

```rs
let guess: u32 = "42".parse().expect("Not a number!");
```

* When converting from a larger type to a smaller one (for instance `u64` to `u32`) you could lose data.
* Converting from a floating point to an integer **will** lose everything behind the decimal point, effectively rounding down.


Rust has two data type subsets: scalar and compound.

### Scalar Types

A *scalar* type represents a single value. Rust has four primary scalar types: `(integers, floating-point) Numbers, Booleans, and characters`.

#### Integer Numbers

Numbers without a fractional component.

```yml
Length:  Signed	Unsigned
8-bit:   i8     u8
16-bit:  i16    u16
32-bit:  i32    u32
64-bit:  i64    u64
128-bit: i128   u128
arch:    isize  usize # 64 bits if you’re on a 64-bit architecture
                  # and 32 bits if you’re on a 32-bit architecture
```

You can write integer **literals** in

```yml
Decimal: 98_222 # _ is visual separator of 98222
Hex: 0xff
Octal: 0o77
Binary: 0b1111_0000
Byte: b'A' # u8 only
```

Number literals that can be multiple numeric types allow a type suffix, such as `57u8`, to designate the type.
`integer` types default to `i32` (e.g when indexing some sort of collection).


> :warning: **Note:** If you try to change the variable to a value outside that range, integer **overflow** will occur:
>   * When you’re compiling in debug mode, Rust includes checks for integer overflow that cause your program to panic at runtime if this behavior occurs.
>   * When you’re compiling in release mode with the `--release` flag, Rust does not check it. Instead, Rust performs two’s complement wrapping: values greater than the maximum value the type can hold "wrap around" to the minimum of the values the type can hold.

#### Floating-Point Numbers

floating-point, which are numbers with decimal points (IEEE-754 Standard), has two primitive types: `f32` and `f64` (default).


### Numeric Operations
Basic mathematical operations you’d expect for all the number types:

```rs
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1
    // Integer division truncates toward zero to the nearest integer

    // remainder
    let remainder = 43 % 5;
}
```

[Appendix B](https://rust-book.cs.brown.edu/appendix-02-operators.html) contains a list of all operators that Rust provides.
